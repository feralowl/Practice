# Practice

5. 1 Доступ к файловой системе

Допустим, в программе создается экземпляр класса File:

    String pathToFile = ...;
    File file = new File(pathToFile);
    
 - Директория
 - Файл
 - Ничего не создается (+)
 - Файл или директория, в зависимости от наличия символа "/" в конце переданной строки pathToFile.
 
Какая базовая директория используется для превращения относительного пути к файлу или директории на диске в абсолютный путь? Речь о методах File.getAbsolutePath(), File.getAbsoluteFile() и Path.toAbsolutePath().

 - Текущая директория Java-процесса, т.е. в какой директории введена команда "java -jar ...". (+)
 - Директория, где находится JAR, из которого запущена программа.
 - Корневая директория файловой системы (C:\ — под Windows, / — под Unix)
 - Директория, где установлен JDK.
 
Найдите среди приведенных путей два эквивалентных, то есть указывающих на один и тот же файл.

 - a\b\..\file.txt
 - .\a\b\..\b\c\.\file.txt (+)
 - a\b\c\file.txt (+)
 - a\.\b\..\c\.\file.txt
 - a\..\b\c\file.txt
 
В чем отличия java.io.File и java.nio.file.Path?

 - Path — это класс, File — это интерфейс.
 - Методы работы с ФС через объект Path при ошибках ввода-вывода бросают исключения; методы работы с File при ошибках возвращают false. (+)
 - Path — это устаревший способ доступа к файловой системе, File — это новый рекомендуемый способ.
 - File — это старый способ доступа к файловой системе, Path — это новый рекомендуемый способ. (+)
 - Path допускает работу с файлами на виртуальных файловых системах, а File нет. (+)
 - File — это класс, Path — это интерфейс. (+)
 - File допускает работу с файлами на виртуальных файловых системах, а Path нет.
 - Методы работы с ФС через объект File при ошибках ввода-вывода бросают исключения; методы работы с Path при ошибках возвращают false.
 
5. 2 Потоки байт

Каким образом методы read() класса InputStream сигнализируют о достижении конца входного потока?

 - Возвращают null.
 - Бросают исключение java.io.EndOfStreamException.
 - Возвращают специальное значение EOF.
 - Возвращают -1. (+)
 
Предположим, у нас есть экземпляр Path, содержащий путь к файлу на реальной или виртуальной файловой системе. Как правильно получить InputStream для чтения содержимого этого файла? (Можно выбрать несколько вариантов.)

 - new FileInputStream(path.toFile())
 - Paths.newInputStream(path)
 - Files.newInputStream(path) (+)
 - new FileInputStream(path)
 
Есть следующий код:

    FileInputStream fileInputStream = new FileInputStream(file);
    try (DataInputStream dataInputStream = new DataInputStream(fileInputStream)) {
        // ...
    }
    
Является ли проблемой то, что не вызван метод fileInputStream.close()? Почему?

 - Нет, т.к. FileInputStream не использует никаких системных ресурсов, которые надо освобождать.
 - Нет, т.к. DataInputStream в своем методе close() закроет InputStream, с которым работает. (+)
 - Да, т.к. это приведет к утечке ресурсов.
 - Да, т.к. пока этот FileInputStream не закрыт, мы не можем открыть новый FileInputStream.
 
Задача № 1

Напишите метод, читающий входной поток и вычисляющий контрольную сумму прочитанных данных.

Контрольная сумма данных вычисляется по следующему алгоритму:

Контрольная сумма представляет собой число типа int. Контрольная сумма пустого набора данных равна нулю.
Контрольная сумма непустого набора данных вычисляется по следующей рекуррентной формуле: Cn+1=rotateLeft(Cn) xor bn+1 , где Cn — контрольная сумма первых n байт данных, rotateLeft — циклический сдвиг бит числа на один бит влево (чтобы не изобретать велосипед, используйте Integer.rotateLeft), bn — n-ный байт данных.
Поскольку метод не открывал данный InputStream, то и закрывать его он не должен. Выброшенное из методов InputStream исключение должно выбрасываться из метода.

    public static int checkSumOfStream(InputStream inputStream) throws IOException {
        int result = 0;
        int n = inputStream.read();
        while(n > -1) {
            result = Integer.rotateLeft(result, 1) ^ n;
            n = inputStream.read();
        }
        return result;
    }
    
Задача № 2

По историческим причинам на разных платформах принят разный способ обозначения конца строки в текстовом файле. На Unix-системах конец строки обозначается символом с кодом 10 ('\n'), на Windows — двумя последовательными символами с кодами 13 и 10 ('\r' '\n').
Напишите программу, которая будет преобразовывать переводы строк из формата Windows в формат Unix. Данные в формате Windows подаются программе в System.in, преобразованные данные должны выводиться в System.out. На этот раз вам надо написать программу полностью, т.е. объявить класс (с именем Main — таково ограничение проверяющей системы), метод main, прописать все import'ы.
Требуется заменить все вхождения пары символов '\r' и '\n' на один символ '\n'. Если на входе встречается одиночный символ '\r', за которым не следует '\n', то символ '\r' выводится без изменения.
Кодировка входных данных такова, что символ '\n' представляется байтом 10, а символ '\r' — байтом 13. Поэтому программа может осуществлять фильтрацию на уровне двоичных данных, не преобразуя байты в символы.
Из-за буферизации данных в System.out в конце вашей программы надо явно вызвать System.out.flush(). Иначе часть выведенных вами данных не будет видна проверяющей системе.

    import java.io.*;
    public class Main {
        public static void main(String[] args) throws IOException {
            byte n, l;
                int i = 0;
                while ((n = (byte) System.in.read()) != -1){
                    if (n == 13){
                        l = n;
                        i++;
                        n = (byte) System.in.read();
                        if (n == 10)
                            System.out.write(n);
                        else if (n != -1){
                            System.out.write(l);
                            System.out.write(n);
                        }
                    } else if (n != -1){
                        System.out.write(n);
                        i++;
                    }
                }
                System.out.flush();
        }
    }
    
5. 3 Потоки символов

В чем отличие классов java.io.InputStream и java.io.Reader? (Можно выбрать несколько вариантов.)

 - Методы Reader бросают исключение java.io.IOException, методы InputStream — нет.
 - InputStream работает на уровне символов Unicode, Reader — на уровне байт.
 - Методы InputStream бросают исключение java.io.IOException, методы Reader — нет.
 - InputStream — устаревший класс, Reader — современный.
 - Reader — устаревший класс, InputStream — современный.
 - Reader работает на уровне символов Unicode, InputStream — на уровне байт. (+)
 
Какую кодировку будут использовать классы java.io.InputStreamReader и java.io.OutputStreamWriter для преобразования байт в символы и обратно, если кодировка не будет передана в конструктор?

 - Всегда Windows-1251
 - Зависит от ОС, настроек и параметров запуска JVM (+)
 - Всегда UTF-8
 - Всегда ASCII
 
Какими байтами представляется символ 'Ы' в кодировке UTF-8? Введите десятичные беззнаковые значения байт через пробел, например, 10 34 254.

 - 208 171
 
Рассмотрим следующий код:

    Writer writer = new OutputStreamWriter(outputStream, StandardCharsets.US_ASCII);

Что будет фактически записано в outputStream, если мы попытаемся вывести через writer символ, не представимый в указанной ему кодировке ASCII? Например, какой-нибудь иероглиф или символ кириллицы.

 - Байт 63 (ASCII-код символа '?') (+)
 - Байт 0
 - Ни одного байта выведено не будет
 - Будет брошено исключение
 - Байт 32 (ASCII-код пробела)
 
Задача № 1

Реализуйте метод, который зачитает данные из InputStream и преобразует их в строку, используя заданную кодировку.

Пример: 

InputStream последовательно возвращает четыре байта: 48 49 50 51.
Метод, вызванный для такого InputStream и кодировки ASCII, должен вернуть строку "0123".

    public static String readAsString(InputStream inputStream, Charset charset) throws IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        byte[] buffer = new byte[4096];
        int nRead;
        while ((nRead = inputStream.read(buffer)) != -1) {
           out.write(buffer, 0, nRead);
        }
        return new String(out.toByteArray(), charset);
    }
    
Задача № 2

Напишите программу, читающую текст из System.in и выводящую в System.out сумму всех встреченных в тексте вещественных чисел с точностью до шестого знака после запятой. Числом считается последовательность символов, отделенная от окружающего текста пробелами или переводами строк и успешно разбираемая методом Double.parseDouble.
На этот раз вам надо написать программу полностью, т.е. объявить класс (с именем Main — таково ограничение проверяющей системы), метод main, прописать все import'ы.

    import java.util.Scanner;
    public class Main {
        public static void main(String[] args){
            double sum = 0;
            try (Scanner scan = new Scanner(System.in)){
                while(scan.hasNext()){
                    if(scan.hasNextDouble()){
                        sum += Double.parseDouble(scan.next());
                    } 
                    else {
                        scan.next();
                    }
                }            
                System.out.printf("%.6f", sum);
            } catch(Exception e){
                System.out.printf("%.6f", 0);
            }
        }
    }

5. 4 Продвинутые возможности

Какие задачи не решаются средствами стандартной библиотеки Java и поэтому требуют запуска внешних процессов при помощи ProcessBuilder? (Можно выбрать несколько вариантов.)

 - Получение информации о владельце файла и его правах
 - Распаковка ZIP-архива
 - Запуск и остановка служб ОС (+)
 - Форматирование диска (+)
 - Удаление непустой директории
 - Установка TCP-соединения с удаленным компьютером
 
В чем разница между классами ввода-вывода, лежащими в пакетах java.io (такими как InputStream, OutputStream, Reader, Writer) и java.nio (такими как Channel, ByteBuffer)?
Можно выбрать несколько вариантов.

 - Классы java.io бросают java.io.IOException, классы java.nio бросают java.nio.NIOException.
 - Классы java.nio являются устаревшими, рекомендуется использовать java.io.
 - Классы java.nio поддерживают неблокирующий ввод-вывод, а java.io — блокирующий.
 - Классы java.io поддерживают неблокирующий ввод-вывод, а java.nio — блокирующий.
 - Классы java.io предоставляют более низкоуровневый интерфейс, пользуясь которым можно писать более эффективные и масштабируемые программы.
 - Классы java.nio предоставляют более низкоуровневый интерфейс, пользуясь которым можно писать более эффективные и масштабируемые программы.
 - Классы java.io являются устаревшими, рекомендуется использовать java.nio.
 
Укажите условия, необходимые для того, чтобы экземпляры класса можно было записывать в ObjectOutputStream и читать из ObjectInputStream. (Можно выбрать несколько вариантов.)

 - В классе должны быть определены методы readObject(ObjectInputStream) и writeObject(ObjectOutputStream).
 - Класс должен реализовывать интерфейс java.io.Serializable. (+)
 - Класс должен быть прописан в конфигурационном файле serialization.properties.
 - В классе должен быть конструктор без параметров.
 - Класс должен быть финальным.
 - Поля класса должны быть объявлены с модификатором transient.
 
 Задача № 1
 
Дан сериализуемый класс Animal:

    class Animal implements Serializable {
        private final String name;
        public Animal(String name) {
            this.name = name;
        }
        @Override
        public boolean equals(Object obj) {
            if (obj instanceof Animal) {
                return Objects.equals(name, ((Animal) obj).name);
            }
            return false;
        }
    }

Реализуйте метод, который из переданного массива байт восстановит массив объектов Animal. Массив байт устроен следующим образом. Сначала идет число типа int, записанное при помощи ObjectOutputStream.writeInt(size). Далее подряд записано указанное количество объектов типа Animal, сериализованных при помощи ObjectOutputStream.writeObject(animal).
Если вдруг массив байт не является корректным представлением массива экземпляров Animal, то метод должен бросить исключение java.lang.IllegalArgumentException.
Причины некорректности могут быть разные. Попробуйте подать на вход методу разные некорректные данные и посмотрите, какие исключения будут возникать. Вот их-то и нужно превратить в IllegalArgumentException и выбросить. Если что-то забудете, то проверяющая система подскажет. Главное не глотать никаких исключений, т.е. не оставлять нигде пустой catch.

(?)
